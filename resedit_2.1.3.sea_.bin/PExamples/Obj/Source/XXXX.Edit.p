{File ResXXXXEd.pCopyright Apple Computer, Inc. 1985-1990All rights reserved.}UNIT ResXXXXed;{XXXX Editor for ResEdit}INTERFACE	USES	Memtypes, QuickDraw, OSIntf, ToolIntf, PackIntf,				ResEd;		{$R-} {Range checking off }	TYPE		rXXXXPtr = ^rXXXXRec;		rXXXXHandle = ^rXXXXPtr;		rXXXXRec = RECORD								 father: ParentHandle;		{ Back ptr to dad }								 name: str255; 						{ The name of this editor }								 wind: WindowPtr;					{ This view's window }								 rebuild: BOOLEAN;				{ Set TRUE if things have changed }								 resWasntLoaded: BOOLEAN;	{ TRUE if the resource should be released when the window is closed. }								 windowType: PossibleWindowTypes;								 theResType: ResType;			{ Type of the resource being picked or edited. }								 theResFile: INTEGER;			{ The home resfile of the window. }								 codeResID: INTEGER;			{ Resource ID of the RSSC resource containing the picker or editor. }								 hXXXX: Handle;						{ The resource we are working on }							 END; {rXXXXRec}	PROCEDURE EditBirth(thing: Handle; Dad: ParentHandle);	PROCEDURE PickBirth(t: ResType; Dad: ParentHandle);	PROCEDURE DoEvent(VAR Evt: EventRecord; myXXXX: rXXXXHandle);	PROCEDURE DoInfoUpdate(oldID, newID: INTEGER; myXXXX: rXXXXHandle);	FUNCTION IsThisYours (thing: Handle; myXXXX:rXXXXHandle): BOOLEAN;	PROCEDURE DoMenu(Menu, Item: INTEGER; myXXXX: rXXXXHandle);IMPLEMENTATION	CONST		windowWidth = 300;		windowHeight = 100;		sizeOfXXXXResource = 10;				{- - -	-  - -	-  -	- -  -	- - -  - -	- - -  -	- -  -	-}	{ Fix up the window name and title for our window. }	PROCEDURE GetNameAndTitle(VAR windowTitle, windowName: STR255; thing: Handle);		BEGIN		windowTitle := '';		SetETitle(thing, windowTitle);		windowName := Concat('XXXX', windowTitle);		windowTitle := Concat('XXXX', windowTitle);		END; { **************************************************************************************** }	PROCEDURE EditBirth(thing:Handle; dad:ParentHandle);		VAR			myXXXX: rXXXXHandle;			myWindow: WindowPtr;			windowTitle, windowName: STR255;		BEGIN {EditBirth}		{ Prepare window title and request creation of a new window }		GetNameAndTitle(windowTitle, windowName, thing);		myWindow := EditorWindSetup(noDialog, noColor, windowWidth, windowHeight, windowTitle, windowName, TRUE, ResEdId, dad);				{ If we got a new window, then start up the editor }		IF myWindow <> NIL THEN			BEGIN			IF GetHandleSize(thing) = 0 THEN { This was called via a NEW, so make a new resource }				FixHand(sizeOfXXXXResource, thing);			{ Get memory for and handle to our instance record }			myXXXX := rXXXXHandle(NewHandle(SIZEOF(rXXXXRec)));			IF MemError <> noErr THEN				BEGIN				CloseWindow(myWindow);				WindReturn(myWindow);				{ Mark the window record as being available }				Exit (EditBirth);				END;							BubbleUp(Handle(myXXXX));			HLock(Handle(myXXXX));			WITH myXXXX^^ DO				BEGIN				{ Put information about this incarnation of the editor and the window it is }				{ serving into our record.(always passed around in the handle myXXXX).  }								father := dad;				name := windowName;				wind := myWindow;				rebuild := false;				resWasntLoaded := NOT WasItLoaded;				windowType := editorWindow;				theResType := 'XXXX';				theResFile := HomeResFile (thing);				codeResID := ResEdID;				hXXXX := thing;								{ Let the main program know who is to manage this window by giving it our 	}				{ instance record handle.		}				WindowPeek(myWindow)^.refCon := ORD(myXXXX);				END; {WITH}							{ Set up any menus,views, etc. for this window here. }						HUnlock(Handle(myXXXX));			END; { IF myWind <> NIL }		END; { EditBirth }	{- -	-  - - -	- -  - - -	-  - -	-  -	- -  -	- - -  - -}	{ Not used for editors. }	PROCEDURE PickBirth(t:ResType;Dad:ParentHandle);		BEGIN { PickBirth }		END; 	{ PickBirth }	{- -	-  - - -	- -  - - -	-  - -	-  -	- -  -	- - -  - -}	PROCEDURE DoEvent(VAR Evt:EventRecord; myXXXX:rXXXXHandle);		VAR			MousePoint: Point;			act: BOOLEAN;		BEGIN {DoEvent}		BubbleUp(Handle(myXXXX)); 			{ Move our item up in memory }		HLock(Handle(myXXXX)); 					{ Lock it down }		WITH myXXXX^^ DO			BEGIN			{ Handle event passed to us by main program.  Just like a 'real' event loop, except…				 there is no loop and we don't have to handle as much because the main program				 will do all the stuff that doesn't apply to us. }							SetPort(wind);								{ Set the port to our window }						CASE Evt.what OF				mouseDown:					BEGIN					MousePoint := Evt.where;	{ Point at which the event occured }					GlobalToLocal(MousePoint);{ Convert event location to local coords }												{ Do any special mouse down processing here. }					END; { mouseDown }				activateEvt:					BEGIN					act := ODD(Evt.modifiers);					IF act THEN						BEGIN						AbleMenu(editMenu, editNone);												{ Do any activate processing here (such as inserting a menu). }						END					ELSE						BEGIN												{ Do any deactivate processing here (such as deleting a menu). }						END;					END {activateEvt} ;				updateEvt:					BEGIN												{ Do the appropriate update processing here.  Remember that 													BeginUpdate has already been called. }					PaintRect(wind^.portrect);					END; {updateEvt}				keyDown:					BEGIN												{ Do any key processing here. }										{ Convert the delete character into a clear command. }					IF (band(evt.message, charCodeMask) = deleteKey) THEN						DoMenu (editMenu, clearItem, myXXXX)					END; {keyDown}								nullEvent:					BEGIN											{ Do any null event processing here (such as blinking a cursor).	}					END;				END;	{ CASE evt.what }			END; 		{ WITH myXXXX^^ }					HUnlock(Handle(myXXXX));		END; 			{ DoEvent }	{- -	-  - - -	- -  - - -	-  - -	-  -	- -  -	- - -  - -}	PROCEDURE DoInfoUpdate(oldID,newID:INTEGER;myXXXX:rXXXXHandle);		VAR			windowTitle, windowName: STR255;		BEGIN { DoInfoUpdate }		HLock(Handle(myXXXX)); 				{ Lock it down }		WITH myXXXX^^ DO			BEGIN 			{ Since our ID has changed, we need to change our window title }			GetNameAndTitle (windowTitle, windowName, Handle(hXXXX));			GetWindowTitle (windowTitle, windowName, TRUE, father);			name := windowName;								{ Save the new name in my data structure. }			SetWTitle(wind, windowtitle);			{ Set the new window title. }				{ Now, let our father object know that our ID has been changed }			father^^.rebuild := TRUE;					{ Rebuild the picker list. }			CallInfoUpdate(oldID, newID, LONGINT(father), father^^.wind^.windowKind);			END; { WITH myXXXX^^ }		HUnlock(Handle(myXXXX));		END; { DoInfoUpdate }	{- -	-  - - -	- -  - - -	-  - -	-  -	- -  -	- - -  - -}			FUNCTION IsThisYours (thing: Handle; myXXXX:rXXXXHandle): BOOLEAN;			BEGIN		IsThisYours := (Handle(myXXXX^^.hXXXX) = thing);		END;	{- -	-  - - -	- -  - - -	-  - -	-  -	- -  -	- - -  - -}	PROCEDURE DoMenu(Menu, Item:INTEGER; myXXXX:rXXXXHandle);		{ Close down the window and get rid of any memory that has been allocated. }		{ Returns TRUE if the operation was successful. If notRevert is false the resource isn't			released and the data handle isn't disposed (though all the handles it contains			are disposed). }		FUNCTION DoClose (notRevert: BOOLEAN): BOOLEAN;			BEGIN			PassMenu(fileMenu, closeItem, ParentHandle(myXXXX));			IF WasAborted THEN				DoClose := FALSE			ELSE				BEGIN				WITH myXXXX^^ DO					BEGIN					CloseWindow(wind);					WindReturn(wind);						{ Mark the window record as being available }					SetTheCursor (arrowCursor); { Make sure the cursor is the arrow cursor }										{ Delete any menus that we added and the redraw menu bar 	}					{ Be sure to dispose of any handles you are done with	}										{ Release the resource if we were launched from a picker }					IF notRevert & resWasntLoaded & (father^^.windowType <> editorWindow) THEN						ReleaseResource (Handle(hXXXX));  { Let it be free (if it is not changed)! }					END; { WITH myXXXX^^ }				IF notRevert THEN					DisposHandle(Handle(myXXXX));				DoClose := TRUE;				END;			END; { DoClose }		BEGIN {DoMenu}		BubbleUp(Handle(myXXXX));		HLock(Handle(myXXXX));		WITH myXXXX^^ DO			BEGIN			SetPort(wind); { Set the port to our window }						{ Again, we handle the menu stuff just as we would in a 'real' application				except that we only have to handle those items that apply to our editor. }			CASE Menu OF				fileMenu:					CASE Item OF						CloseItem:							BEGIN							IF DoClose (TRUE) THEN 			{	Close our window }								EXIT(DoMenu); 						{	Return immediately since our resource is gone!	}							END; { CloseItem }													saveItem:				{ Pass the save on to other windows. }							PassMenu(fileMenu, saveItem, ParentHandle(myXXXX));													printItem:							PrintWindow (NIL);						END; { Case }										rsrcMenu:					CASE item OF						rsrcRevertItem:							BEGIN							IF NeedToRevert (wind, Handle(hXXXX)) THEN								BEGIN								{ The area under the window will need to be updated }								InvalRect(wind^.portrect);																{ Read in the old copy from disk (see documentation for revertResource).  Clear it out 									unless this  was a newly created resource, in which case don't. }								IF NOT RevertThisResource(ParentHandle(myXXXX), Handle(hXXXX)) THEN									BEGIN		{ The resource was newly added so we need to remove it. }																		{ Make sure that the picker list is rebuilt to remove this item. }									myXXXX^^.father^^.rebuild := TRUE;																		IF DoClose (FALSE) THEN											{ Close the window. }										BEGIN										RERemoveAnyResource (theResFile, Handle (hXXXX));	{ Dispose the resource itself. }										DisposHandle (Handle(myXXXX));										EXIT(DoMenu);										END;									END; {IF NOT RevertResource…}								END;							END; { RevertItem }													rsrcGetInfoItem:							BEGIN							{ Put up the GetInfo window. }							ShowInfo(Handle(hXXXX), ParentHandle(myXXXX));							END; { GetInfoItem }					END; {rsrcmenu: CASE Item OF}				EditMenu:					CASE Item OF						{ Implement the edit menu here. }						CutItem: ;						CopyItem: ;						PasteItem: ;						ClearItem: ;					END; { EditMenu }				END; { CASE Menu OF }			END; { WITH myXXXX^^}		HUnlock(Handle(myXXXX));		END; {DoMenu}END.