/*File ResXXXXEd.cCopyright Apple Computer, Inc. 1985-1990All rights reserved.*/#include	<types.h>#include	<memory.h>#include	<menus.h>#include	<resources.h>#include	"ResEd.h"#define		windowWidth			300#define		windowHeight		100#define		sizeOfXXXXResource	10typedef struct rXXXXRec	{	ParentHandle	father;			/* Back ptr to dad */	Str255			name;			/* The name of this editor */	WindowPtr		wind;			/* This view's window */	Boolean			rebuild;		/* Set true if things have changed */	Boolean			resWasntLoaded;	/* TRUE if the resource should be released when the window is closed. */	unsigned char	windowType;	ResType			theResType;		/* Type of the resource beingedited. */	short			theResFile;		/* The home resfile of the window. */	short			codeResID;		/* Resource ID of the RSSC resource containing the picker or editor. */	Handle			hXXXX;			/* The resource we are working on */	} rXXXXRec;typedef rXXXXRec	*rXXXXPtr;typedef rXXXXPtr	*rXXXXHandle;/* Function prototypes. */pascal void DoMenu(short menu, short item, rXXXXHandle myXXXX);/*- -	-  -  - -  -  -  - -  -  -	- -  -	-  - -	-  -  - -  -  -*//* Fix up the window name and title for our window. */void GetNameAndTitle(StringPtr windowTitle,StringPtr windowName,Handle thing)	{	strcpy(windowTitle,"\pXXXX");	SetETitle(thing,windowTitle);	strncpy(windowName,windowTitle,*windowTitle + 1);	/* Add 1 for the length byte */	}/*- -  -  -	- -  -	-  - -	-  -  - -  -  -  - -  -  -	- -  -	-*/pascal void EditBirth(Handle thing,ParentHandle dad)	{	rXXXXHandle		myXXXX;	WindowPtr		myWindow;	Str255			windowTitle,windowName;	/* Prepare window title and request creation of a new window */	GetNameAndTitle(windowTitle, windowName, thing);	myWindow = EditorWindSetup(noDialog, noColor, windowWidth, windowHeight, windowTitle, windowName, true, ResEdID(), dad);	/* If we got a new window, then start up the editor */	if (myWindow != nil)		{		/* This was called via a NEW, so make a new resource. */		if (GetHandleSize(thing) == 0L)			FixHand(sizeOfXXXXResource,thing);		/* Get memory for and handle to our instance record */		myXXXX = (rXXXXHandle)NewHandle(sizeof(rXXXXRec));		if (MemError() != noErr)			{			CloseWindow(myWindow);			WindReturn(myWindow);				/* Mark the window record as being available */			return;			}		/* Put information about this incarnation of the editor and the window it is */		/* serving into our record.(always passed around in the handle myXXXX).	 */		(*myXXXX)->father = dad;		strncpy((*myXXXX)->name, windowName, windowName[0] + 1);	/* Add 1 for the length byte */		(*myXXXX)->wind = myWindow;		(*myXXXX)->rebuild = false;		(*myXXXX)->resWasntLoaded = !WasItLoaded();		(*myXXXX)->windowType = editorWindow;		(*myXXXX)->theResType = 'XXXX';		(*myXXXX)->theResFile = HomeResFile(thing);		(*myXXXX)->codeResID = ResEdID();		(*myXXXX)->hXXXX = thing;						/* Let the main program know who is to manage this window by giving it both	*/		/* our resource ID number and our instance record handle.		*/		((WindowPeek)myWindow)->refCon = (long)myXXXX;		/* Set up any menus,views, etc. for this window here. */		}	}/*- -  -  -	- -  -	-  - -	-  -  - -  -  -  - -  -  -	- -  -	-*//* Not used for editors. */pascal void PickBirth(ResType t, ParentHandle dad)	{#pragma	unused (t, dad)	}/*- -  -  -	- -  -	-  - -	-  -  - -  -  -  - -  -  -	- -  -	-*/pascal void DoEvent(EventRecord *evt, rXXXXHandle myXXXX)	{	Point		mousePoint;	BubbleUp((Handle)myXXXX);		/* Move our item up in memory */	HLock((Handle)myXXXX);			/* Lock it down */	/* Handle event passed to us by main program.  Just like a 'real' event loop, exceptÉ	*/	/* there is no loop and we don't have to handle as much because the main program	*/	/* will do all the stuff that doesn't apply to us.					*/	SetPort((*myXXXX)->wind);		/* Set the port to our window */	switch (evt->what)		{		case mouseDown:			mousePoint = evt->where;	/* Point at which the event occured */			GlobalToLocal(&mousePoint);	/* Convert event location to local coords */			break;						/* Do any special mouse down processing here. */			case activateEvt:			if (evt->modifiers & activeFlag)				{				AbleMenu(editMenu, editNone);				/* Do any activate processing here (such as inserting a menu) */				}			else				{				/* Do any deactivate processing here (such as deleting a menu). */				}			break;			case updateEvt:			/* Do the appropriate update processing here.  Remember that BeginUpdate has already been called. */			PaintRect(&(*myXXXX)->wind->portRect);			break;			case keyDown:			/* Do any key processing here. */			if ((evt->message & charCodeMask) == deleteKey)	/* Convert the delete character into a clear command. */				{				DoMenu(editMenu, clearItem, myXXXX);			}		break;	case nullEvent:		/* Do any null event processing here (such as blinking a cursor).	*/		break;		}	HUnlock((Handle)myXXXX);	}	/*- -  -  -	- -  -	-  - -	-  -  - -  -  -  - -  -  -	- -  -	-*/pascal void DoInfoUpdate(short oldID, short newID, rXXXXHandle myXXXX)	{	ParentHandle 	father = (*myXXXX)->father;	Str255			windowTitle,windowName;	HLock((Handle)myXXXX);	/* Since our ID has changed, we need to change our window title */	GetNameAndTitle(windowTitle, windowName, (Handle)(*myXXXX)->hXXXX);	GetWindowTitle(windowTitle, windowName,true, (*myXXXX)->father);	/* Save the new name in my data structure. */	strncpy((*myXXXX)->name, windowName, windowName[0] + 1);	/* Add 1 for the length byte. */	SetWTitle((*myXXXX)->wind, windowTitle);	/* Set the new window title. */	/* Now, let our father object know that our ID has been changed */	(*father)->rebuild = true;			/* Rebuild the picker list. */	CallInfoUpdate(oldID, newID, (long)father, (*father)->wind->windowKind);	HUnlock((Handle)myXXXX);	}/*- -  -  -	- -  -	-  - -	-  -  - -  -  -  - -  -  -	- -  -	-*/pascal Boolean IsThisYours(Handle thing, rXXXXHandle myXXXX)	{	return (thing == (Handle)(*myXXXX)->hXXXX);	}/*- -  -  -	- -  -	-  - -	-  -  - -  -  -  - -  -  -	- -  -	-*//* 	Close down the window and get rid of any memory that has been allocated.	Returns TRUE if the operation was successful. If notRevert is false the resource isn't	released and the data handle isn't disposed (though all the handles it contains	are disposed).  */static Boolean DoClose(Boolean notRevert, rXXXXHandle myXXXX)	{	PassMenu (fileMenu, closeItem, (ParentHandle)myXXXX);	if (WasAborted())		{		return false;		}	else		{		CloseWindow((*myXXXX)->wind);		WindReturn((*myXXXX)->wind);	/* Mark the window record as being available */		SetTheCursor(arrowCursor);	/* Make sure the cursor is the arrow cursor */			/* Delete any menus that we added and redraw the menu bar.	*/		/* Be sure to dispose of any handles you are done with.		*/		/* Release the resource if we were launched from a picker. */		if ((notRevert) && ((*myXXXX)->resWasntLoaded) && ((*((*myXXXX)->father))->windowType != editorWindow))			ReleaseResource((Handle)(*myXXXX)->hXXXX);	/* Let it be free (if it is not changed)! */				if (notRevert)			DisposHandle((Handle)myXXXX);		return true;		}	}/*- -  -  -	- -  -	-  - -	-  -  - -  -  -  - -  -  -	- -  -	-*/pascal void DoMenu(short menu, short item, rXXXXHandle myXXXX)	{	BubbleUp((Handle)myXXXX);	HLock((Handle)myXXXX);	SetPort((*myXXXX)->wind);					/* Set the port to our window */	/* Again, we handle the menu stuff just as we would in a 'real' application	*/	/* except that we only have to handle those items that apply to our editor.	*/			switch (menu)		{		case fileMenu:			switch (item)				{				case closeItem:					if (DoClose(true, myXXXX))	/* Close our window						*/						{						return;					/* Return immediately since our resource is gone! */						}					break;				case saveItem:				/* Pass the save on to other windows.	*/					PassMenu(fileMenu,saveItem, (ParentHandle)myXXXX);					break;				case printItem:					PrintWindow(nil);					break;				}			break;		case rsrcMenu:			switch(item)				{				case rsrcRevertItem:					if (NeedToRevert((*myXXXX)->wind, (Handle)(*myXXXX)->hXXXX))						{						/* The area under the window will need to be updated 	*/						InvalRect(&(*myXXXX)->wind->portRect);								/* Read in the old copy from disk (see documentation for revertResource)	*/						/* Clear it out unless this was a newly created resource	*/						if (!RevertThisResource((ParentHandle)myXXXX, (Handle)(*myXXXX)->hXXXX))							{							/* The resource was newly added so we need to remove it.*/									/* Make sure that the picker list is rebuilt to remove this item. 										*/							(*((*myXXXX)->father))->rebuild = true;									if (DoClose(false, myXXXX))	/* Close the window.			*/								{								RERemoveAnyResource((*myXXXX)->theResFile, (*myXXXX)->hXXXX);	/* Dispose the resource itself. */								DisposHandle((Handle)myXXXX);								return;					/* Since the resource is gone.	*/								}							}						}					break;				case rsrcGetInfoItem:		/* Show GetInfo window */					ShowInfo((Handle)(*myXXXX)->hXXXX,(ParentHandle)myXXXX);					break;				}			break;		case editMenu:			/* Implement the edit menu here	*/			switch (item)				{				case cutItem:					break;				case copyItem:					break;				case pasteItem:					break;				case clearItem:					break;				}			break;		}	HUnlock((Handle)myXXXX);	}